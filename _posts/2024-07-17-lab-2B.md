---
title: "（6.5840）lab 2B"
date: 2024-07-17
image: images/pass_2B.png
---

# 概述
lab 2B 难度就大起来了，标注的是hard，也确实hard。

下班后晚上零零碎碎的看论文，修改代码，还有一个周天，从中午到晚上七点，终于通过所有case，发现自己真叼（感谢老婆🙏）。

读几遍那个lab 实现说明大概就明白了，如果英语有困难，可以装一个插件，叫沉浸式翻译。

主要功能我提炼出来就是俩：
1. 接受client的命令，也就是要实现start 方法，
2. 完善心跳：一开始心跳没有携带数据嘛，现在要携带数据了。
3. 修复选举代码的BUG。
 
## 过程
一开始我以为要在start方法中发送数据，所以在这里加了一个 Goroutine 去发送log，写到一半想起来日志要在心跳中携带。

那么start方法就把command 加到 log 里面然后直接返回。

接着开始了调试applyCh的问题，applyCh里面的index 是**从1 开始**，一定要记得！

运行case 加上 -race 命令，这样能检测出很产生数据竞态的地方，很多地方都可能会产生数据竞态，同时这也是你发现明明代码看起来没毛病，但执行起来就是不对。


## 调试遇到的问题
1. 运行测试：TestBasicAgree2B 一直失败，直到再里面加了一些日志之后才发现，applyCh里面的index 是从1 开始的，所以需要 给applyIndex+1


2. 对于 apply 和 commit的概念的进一步明确，一开始没办法区分，apply在我理解是说应用到本地的状态机里，commit 是大多数都apply了，所以applyCh里面我是用的applyIndex。
   但实际上到修复一个某个test case重复commit的问题后，我才意识到，apply相当于上一次的commitIndex， 
   这一次的commitIndex是参数带过来，如果apply < commitIndex 就表明有新的log要commit，那么同时写入到applyCh。


3. 然后你会发现，在心跳里面同时会进行commitIndex 的确认和 同步log，所以follower节点是的在下一次心跳commit上一次的log进度， 除非新增返回值字段，那么在append的时候就确认了（2C需要）。


4. 2B测试了很多主节点切换的case，所以投票的第二个条件一定要想明白，什么叫做【候选人的日志至少和自己一样新】。这个条件就是要保持即使在切换后，也是由commitIndex最大的节点担任新的主节点。


5. 关于重试，case中模拟了断连，所以我在投票，追加日志都加了重试，然后调试发现有很多重复的请求，后来看了官方的示意图（[链接](https://raft.github.io/)）才发现， 根本没必要，因为下一次心跳就充当了重试。


6. ticker 方法如果改成timer 更好，不过现在这样更容易理解。


7. 多读几遍论文，有些条件你可能最开始不理解，例如【接收到的 RPC 请求或响应中，任期号T > currentTerm，则令 currentTerm = T，并切换为跟随者状态】，
   这个条件一开始我没理解透彻，在某些case一直失败，又读了原文后，我才明白，举个例子，follower 网络故障了，一直超时，一直发起选举，term蹭蹭往上加。
   后面网络好了，leader节点的term也需要是最新的， 但又不能直接改leader的term，此时需要重新发起选举了，但刚连上的follower日志又不够新，所以还是要让有最新日志的节点选举成功（选举的第二个条件）。


8. 不要用脑子模拟，多打日志，状态很复杂，选举几轮后，脑子就模拟不过来了，多打日志能判别从哪儿开始出现了奇怪的问题。


9. lock使用，不要吝啬使用

## case截图
![pass_2B](/images/pass_2B.png)

## code
答：尽量自己独立完成。

## 附录代码
晚点补充
